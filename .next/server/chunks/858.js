"use strict";exports.id=858,exports.ids=[858],exports.modules={23858:(e,t,r)=>{r.d(t,{_:()=>jwtVerify});var a=r(40554),o=r(55270),i=r(91715),n=r(24929);async function verify(e,t,r,a){let d=await (0,n.f)(e,t,"verify");(0,i.F)(e,d);let c=(0,o.O)(e,d.algorithm);try{return await crypto.subtle.verify(c,d,r,a)}catch{return!1}}var d=r(16395),c=r(52820),y=r(57826),p=r(53168),l=r(51823),s=r(10618),f=r(17890);async function flattenedVerify(e,t,r){let o,i;if(!(0,p.K)(e))throw new d.GW("Flattened JWS must be an object");if(void 0===e.protected&&void 0===e.header)throw new d.GW('Flattened JWS must have either of the "protected" or "header" members');if(void 0!==e.protected&&"string"!=typeof e.protected)throw new d.GW("JWS Protected Header incorrect type");if(void 0===e.payload)throw new d.GW("JWS Payload missing");if("string"!=typeof e.signature)throw new d.GW("JWS Signature missing or incorrect type");if(void 0!==e.header&&!(0,p.K)(e.header))throw new d.GW("JWS Unprotected Header incorrect type");let n={};if(e.protected)try{let t=(0,a.J)(e.protected);n=JSON.parse(c.xv.decode(t))}catch{throw new d.GW("JWS Protected Header is invalid")}if(!(0,y.e)(n,e.header))throw new d.GW("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");let w={...n,...e.header},h=(0,s.E)(d.GW,new Map([["b64",!0]]),r?.crit,n,w),u=!0;if(h.has("b64")&&"boolean"!=typeof(u=n.b64))throw new d.GW('The "b64" (base64url-encode payload) Header Parameter must be a boolean');let{alg:W}=w;if("string"!=typeof W||!W)throw new d.GW('JWS "alg" (Algorithm) Header Parameter missing or invalid');let g=r&&function(e,t){if(void 0!==t&&(!Array.isArray(t)||t.some(e=>"string"!=typeof e)))throw TypeError(`"${e}" option must be an array of strings`);if(t)return new Set(t)}("algorithms",r.algorithms);if(g&&!g.has(W))throw new d.FP('"alg" (Algorithm) Header Parameter value not allowed');if(u){if("string"!=typeof e.payload)throw new d.GW("JWS Payload must be a string")}else if("string"!=typeof e.payload&&!(e.payload instanceof Uint8Array))throw new d.GW("JWS Payload must be a string or an Uint8Array instance");let m=!1;"function"==typeof t&&(t=await t(n,e),m=!0),(0,l.y)(W,t,"verify");let v=(0,c.zo)(void 0!==e.protected?(0,c.cv)(e.protected):new Uint8Array,(0,c.cv)("."),"string"==typeof e.payload?u?(0,c.cv)(e.payload):c.g7.encode(e.payload):e.payload);try{o=(0,a.J)(e.signature)}catch{throw new d.GW("Failed to base64url decode the signature")}let b=await (0,f.k)(t,W),J=await verify(W,b,o,v);if(!J)throw new d.nx;if(u)try{i=(0,a.J)(e.payload)}catch{throw new d.GW("Failed to base64url decode the payload")}else i="string"==typeof e.payload?c.g7.encode(e.payload):e.payload;let S={payload:i};return(void 0!==e.protected&&(S.protectedHeader=n),void 0!==e.header&&(S.unprotectedHeader=e.header),m)?{...S,key:b}:S}async function compactVerify(e,t,r){if(e instanceof Uint8Array&&(e=c.xv.decode(e)),"string"!=typeof e)throw new d.GW("Compact JWS must be a string or Uint8Array");let{0:a,1:o,2:i,length:n}=e.split(".");if(3!==n)throw new d.GW("Invalid Compact JWS");let y=await flattenedVerify({payload:o,protected:a,signature:i},t,r),p={payload:y.payload,protectedHeader:y.protectedHeader};return"function"==typeof t?{...p,key:y.key}:p}var w=r(61868);async function jwtVerify(e,t,r){let a=await compactVerify(e,t,r);if(a.protectedHeader.crit?.includes("b64")&&!1===a.protectedHeader.b64)throw new d.uv("JWTs MUST NOT use unencoded payload");let o=(0,w.Vr)(a.protectedHeader,a.payload,r),i={payload:o,protectedHeader:a.protectedHeader};return"function"==typeof t?{...i,key:a.key}:i}}};